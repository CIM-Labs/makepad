Props: Component{
    x:1
    y:2
    z:[1,2,3]
    w:{x:1,y:2}
}

Class1: Component{
    props_a:Props{zz:3}
}

Class3: Component{
    blarp:15
}

Class2: Class1{
    bliep:[1,2,Class3::blarp{}],
    props_a.a: bliep{}
    props_b: props_a{x:props_a::z{},bbb:props_a::w{}}
}

//Class3:Class2{
//    props2.p5.p7:10
//}

// This file is parsed in Rust, and all components can be instanced there.
// In Rust you can overwrite properties like let live = Live::instance(NormalButton); set_float!(live, layout_bg.padding.l, 1.0); or something like that.
// These 'live' instances can get their code rewritten by the visual designer/code editor as the program runs, and are interpreted in Rust
// However contrary to HTML the Rust flow owns the UI structure, these live instances behave like a normal widget in the UI kit.
// Unlike JSX and other 'template' languages you also won't need to generate this DSL structure with duplicating-items since you can just
// Execute another Live fragment in a loop in Rust.
// Events, expressions, and drawing a UserDraw component are all done in Rust. Otherwise we can't make a visual UI designer for this structure.
// In the visual UI designer subclassing will behave like instancing a component and overriding a few values.
// This system does not use a html renderer. It's all Rust+Wasm/native. Demo of the webGL build: https://makepad.dev

/*use makepad_render::{Component, Frame, DrawQuad};

DrawNormalButton: DrawQuad { // compiled to shader on platform layer (metal, webgl, dx11, etc)
    shadow: 3.0;
    border_radius: 2.5;
    
    fn pixel() -> vec4 {
        let cx = Df::viewport(pos * rect_size);
        cx.box(shadow, shadow, rect_size.x - shadow * (1. + down), rect_size.y - shadow * (1. + down), border_radius);
        cx.blur = 6.0;
        cx.fill(mix(#0007, #0, hover));
        cx.blur = 0.001;
        cx.box(shadow, shadow, rect_size.x - shadow * 2., rect_size.y - shadow * 2., border_radius);
        return cx.fill(mix(mix(#3, #4, hover), #2a, down));
    }
}

NormalButton: Component {
    layout_bg: Layout {
        align: Align::Center, 
        walk: Walk {
            width: Width::Compute,
            height: Height::Compute,
            margin: Margin{l:1.0, t:1.0, r:1.0, b:1.0},
        },
        padding: Padding{l: 16.0, t: 12.0, r: 16.0, b: 12.0},
    }
    
    shader: DrawNormalButton { // shaders behave as classes and can be partially overwritten here
         border_radius: 5.5;
    }
    
    text_style: DefaultTextStyle {
    }
    
    Default: Self { // shows states as instances of self
        shader.down: 0.0
        layout_bg.padding.l: Animation { // all properties can have animation
            play: Play::Cut {duration: 0.1}
            keys: {1.0: 10.0}
        }
        frame.prop: 1.0
    }
    
    Pressed: Self{ // todo: find a way to 'tween' these 2 states
        shader.down: 1.0
    }
}

MyFrame: Frame { // something that layouts / clips
    pos: Vec3{x: 1.0, y: 1.0, z: 1.0}
    size: Vec2{x: 100.0, y: 100.0}
    layout: Layout::Auto {}
    children: [button1, user1, button2]

    // loop this thing somehow
    button1: NormalButton {
        label: "testword"
        layout_bg.padding.l: 1.0 // deep propery overwrites
    }
    button2: NormalButton{
        label: "testword2"
        layout_bg.padding.l: 3.0
    }
    user1: UserDraw{}
}*/
